/*
Copyright (c) 2019 huailiang

# This file is part of neural network impleted with shader

contact: peng_huailiang@qq.com
*/

#pragma kernel StyleEncoderConv 
#pragma kernel StyleEncoderNormal 
#pragma kernel StyleEncoderInstance 
#pragma kernel StylePad 
#pragma kernel StyleConv1 
#pragma kernel StyleNormal1 
#pragma kernel StyleInstance1 
#pragma kernel StyleConv2 
#pragma kernel StyleNormal2 
#pragma kernel StyleInstance2 
#pragma kernel StyleConv3 
#pragma kernel StyleNormal3 
#pragma kernel StyleInstance3 
#pragma kernel StyleConv4 
#pragma kernel StyleNormal4 
#pragma kernel StyleInstance4 
#pragma kernel StyleConv5 
#pragma kernel StyleNormal5 
#pragma kernel StyleInstance5 

#include "libEncoder.cginc"
#include "libEncoderArgs.cginc"

Texture2D<float4> source;
RWStructuredBuffer<float> encoder_inst;
RWStructuredBuffer<float> encoder_inst_statistic;
RWStructuredBuffer<float> encoder_conv0;
RWStructuredBuffer<float> encoder_conv1;
RWStructuredBuffer<float> encoder_conv1_statistic;
RWStructuredBuffer<float> encoder_conv2;
RWStructuredBuffer<float> encoder_conv2_statistic;
RWStructuredBuffer<float> encoder_conv3;
RWStructuredBuffer<float> encoder_conv3_statistic;
RWStructuredBuffer<float> encoder_conv4;
RWStructuredBuffer<float> encoder_conv4_statistic;
RWStructuredBuffer<float> encoder_conv5;
RWStructuredBuffer<float> encoder_conv5_statistic;

/*
***  formula  o=(w-k+2p)/s+1  ***
encoder construct as:
init  256x256x3->
pad	 	286x286x3->  
conv1	  284x284x32->
conv2		141x141x32->
conv3		  70x70x64->
conv4			34x34x128->
conv5			  16x16x256		
*/

[numthreads(8, 8, 3)]
void StyleEncoderConv(uint3 id : SV_DispatchThreadID)
{
	uint width = 256, depth = 3;
	float4 color = source[uint2(id.x, width - id.y - 1)];
	float arr[3] = { color.x, color.y, color.z };
	float v = 2 * arr[id.z] - 1;
	int idx = id.y * width * depth + id.x * depth + id.z;
	encoder_inst[idx] = v;
}


[numthreads(1, 64, 3)]
void StyleEncoderNormal(uint3 id : SV_DispatchThreadID, uint gix : SV_GroupIndex)
{
	uint width = 64, depth = 3, nwidth = 256, scale = nwidth / width;
	uint offset = width * depth;
	uint nix = id.y * depth + id.z;
	g_cache[nix] = 0.0f;
	g_cache[nix + offset] = 0;
	for (uint i = 0; i < nwidth; i++)
	{
		for (uint j = 0; j < scale; j++)
		{
			int idx = i * nwidth  * depth + (id.y + width * j) * depth + id.z;
			g_cache[nix] += encoder_inst[idx];
			g_cache[nix + offset] += pow(abs(encoder_inst[idx]), 2);
		}
	}
	GroupMemoryBarrierWithGroupSync();
	if (id.y == 0) //3 threads limited 
	{
		float mean = 0, qrt = 0;
		for (uint i = 0; i < width; i++)
		{
			int idx = i * depth + id.z;
			mean += g_cache[idx];
			qrt += g_cache[idx + offset];
		}
		int len = nwidth * nwidth;
		mean = mean / len;
		encoder_inst_statistic[id.z * 2] = mean;
		encoder_inst_statistic[id.z * 2 + 1] = qrt / len - mean * mean;
	}
}

[numthreads(8, 8, 3)]
void StyleEncoderInstance(uint3 id : SV_DispatchThreadID)
{
	uint width = 256, depth = 3;
	float4 color = source[uint2(id.x, width - id.y - 1)];
	float arr[3] = { color.x, color.y, color.z };
	int z = id.z;
	int idx = StdID(id, width, depth);
	float mean = encoder_inst_statistic[z * 2];
	float variance = encoder_inst_statistic[z * 2 + 1];
	float inv = rsqrt(variance + EPSILON);
	float normalized = (arr[z] - mean) * inv;
	float scale = encoder_g_e0_bn_scale[z];
	float offset = encoder_g_e0_bn_offset[z];
	encoder_inst[idx] = scale * normalized + offset;
}

[numthreads(8, 8, 3)]
void StylePad(uint3 id : SV_DispatchThreadID) //id.xy=288
{
	uint pad = 15, width = 256, depth = 3;
	if (StdCheckRange(id, width + 2 * pad)) return;
	StdPad(id, width, depth, pad)
	encoder_conv0[indx] = encoder_inst[indx];
}

[numthreads(8,8,1)]
void StyleConv1 (uint3 id : SV_DispatchThreadID) //id.xy=288 286x286x3->284x284x32
{
	uint input = 286, output = 284, depth1 = 3, stride =1;
	uint depth2 = StdCheckRange(id, output) ? 0 : 32;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 1, 0);
}

[numthreads(1, THREAD_Y_32Z, 32)]
void StyleNormal1(uint3 id : SV_DispatchThreadID) //284x284x32
{
	uint width = THREAD_Y_32Z, depth = 32, nwidth = 284;
	DefineEnNormal(id, width, 1);
}

[numthreads(8, 8, 4)]
void StyleInstance1(uint3 id : SV_DispatchThreadID) //284x284x32
{
	uint width = 284, depth = 32;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 1);
}

[numthreads(8,8,1)]
void StyleConv2(uint3 id : SV_DispatchThreadID) //id.xy=144 284x284x32->141x141x32 
{
	uint input = 284, output = 141, depth1 = 32, stride = 2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 32;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 2, 1);
}

[numthreads(1,THREAD_Y_32Z,32)]
void StyleNormal2(uint3 id : SV_DispatchThreadID)  //141x141x32 
{
	uint width = THREAD_Y_32Z, depth = 32, nwidth = 141;
	DefineEnNormal(id, width, 2);
}

[numthreads(8,8,4)]
void StyleInstance2(uint3 id : SV_DispatchThreadID) //id.xy=144 141x141x32
{
	uint width = 141, depth = 32;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 2);
}

[numthreads(8,8,1)]
void StyleConv3 (uint3 id : SV_DispatchThreadID) //id.xy=72 141x141x32->70x70x64
{
	uint input = 141, output = 70, depth1 = 32, stride =2;
	uint depth2 = StdCheckRange(id, output) ? 64 : 0;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 3, 2)
}

[numthreads(1,REV_THREAD_Z,MAX_THREAD_Z)]
void StyleNormal3(uint3 id : SV_DispatchThreadID)  // 70x70x64
{
	uint width = REV_THREAD_Z, depth = 64, nwidth = 70;
	DefineEnNormal(id, width, 3);
}

[numthreads(8,8,4)]
void StyleInstance3 (uint3 id : SV_DispatchThreadID) //id.xy=72 70x70x64 
{
	uint width = 70, depth = 64;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 3);
}

[numthreads(8,8,1)]
void StyleConv4 (uint3 id : SV_DispatchThreadID) //id.xy=40 70x70x64->34x34x128
{
	uint input = 70, output = 34, depth1 = 64, stride =2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 128;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 4, 3);
}

[numthreads(1,REV_THREAD_Z, MAX_THREAD_Z)] 
void StyleNormal4(uint3 id : SV_DispatchThreadID) //34x34x128
{
	uint width = 8, depth = 128, scale = 4;
	DefineEnNormalMaxZ(id, width, depth, scale, 4);
}

[numthreads(8,8,4)]
void StyleInstance4(uint3 id : SV_DispatchThreadID) //id.xy=40 34x34x128
{
	uint width = 34, depth = 128;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 4);
}

[numthreads(8,8,1)]
void StyleConv5(uint3 id : SV_DispatchThreadID) //id.xy=40 34x34x128->16x16x256
{
	uint input = 34, output = 16, depth1 = 128, stride = 2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 256;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 5, 4);
}

[numthreads(1, REV_THREAD_Z, MAX_THREAD_Z)]
void StyleNormal5(uint3 id : SV_DispatchThreadID)  //16x16x256
{
	uint width = 4, depth = 256, scale = 4;
	DefineEnNormalMaxZ(id, width, depth, scale, 5);
}

[numthreads(8,8,4)]
void StyleInstance5 (uint3 id : SV_DispatchThreadID) //id.xy=16 16x16x256
{
	uint width = 16, depth = 256;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 5);
}