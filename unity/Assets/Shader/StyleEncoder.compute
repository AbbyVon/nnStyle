/*
Copyright (c) 2019 huailiang

# This file is part of neural network impleted with shader

contact: peng_huailiang@qq.com
*/

#pragma kernel StyleEncoderConv 
#pragma kernel StyleEncoderNormal 
#pragma kernel StyleEncoderInstance 
#pragma kernel StylePad 
#pragma kernel StyleConv1 
#pragma kernel StyleNormal1 
#pragma kernel StyleInstance1 
#pragma kernel StyleConv2 
#pragma kernel StyleNormal2 
#pragma kernel StyleInstance2 
#pragma kernel StyleConv3 
#pragma kernel StyleNormal3 
#pragma kernel StyleInstance3 
#pragma kernel StyleConv4 
#pragma kernel StyleNormal4 
#pragma kernel StyleInstance4 
#pragma kernel StyleConv5 
#pragma kernel StyleNormal5 
#pragma kernel StyleInstance5 

#include "libEncoder.cginc"
#include "libEncoderArgs.cginc"

Texture2D<float4> source;
RWTexture2D<float4> destination;
RWStructuredBuffer<float> encoder_inst;
RWStructuredBuffer<float> encoder_inst_statistic;
RWStructuredBuffer<float> encoder_conv0;
RWStructuredBuffer<float> encoder_conv1;
RWStructuredBuffer<float> encoder_conv1_statistic;
RWStructuredBuffer<float> encoder_conv2;
RWStructuredBuffer<float> encoder_conv2_statistic;
RWStructuredBuffer<float> encoder_conv3;
RWStructuredBuffer<float> encoder_conv3_statistic;
RWStructuredBuffer<float> encoder_conv4;
RWStructuredBuffer<float> encoder_conv4_statistic;
RWStructuredBuffer<float> encoder_conv5;
RWStructuredBuffer<float> encoder_conv5_statistic;

/*
***  formula  o=(w-k+2p)/s+1  ***
encoder construct as:
init  256x256x3->
pad	 	286x286x3->  
conv1	  284x284x32->
conv2		141x141x32->
conv3		  70x70x64->
conv4			34x34x128->
conv5			  16x16x256		
*/

[numthreads(8, 8, 3)]
void StyleEncoderConv(uint3 id : SV_DispatchThreadID)
{
	uint width = 256, depth = 3;
	float4 color = source[uint2(id.x, width - id.y - 1)];
	float arr[3] = { color.x, color.y, color.z };
	float v = 2 * arr[id.z] - 1;
	int idx = id.y * width * depth + id.x * depth + id.z;
	encoder_inst[idx] = v;
}


[numthreads(1, 64, 3)]
void StyleEncoderNormal(uint3 id : SV_DispatchThreadID, uint gix : SV_GroupIndex)
{
	uint width = 64, depth = 3, scale = 4;
	uint offset = width * depth;
	uint nix = id.y * depth + id.z;
	g_cahce[nix] = 0.0f;
	g_cahce[nix + offset] = 0;
	for (uint i = 0; i < width * scale; i++)
	{
		int idx = i * width * scale * depth + id.y * depth * scale + id.z;
		g_cahce[nix] += encoder_inst[idx];
		g_cahce[nix + offset] += pow(abs(encoder_inst[idx]), 2);
	}
	GroupMemoryBarrierWithGroupSync();

	if (id.y == 0) //3 threads limited 
	{
		float mean = 0.0f, qrt = 0.0f;
		for (uint i = 0; i < width; i++)
		{
			int idx = i * depth + id.z;
			mean += g_cahce[idx];
			qrt += g_cahce[idx + offset];
		}
		int len = width * width * scale;
		mean = mean / len;
		encoder_inst_statistic[id.z * 2] = mean;
		encoder_inst_statistic[id.z * 2 + 1] = qrt / len - pow(abs(mean), 2);
	}
}

[numthreads(8, 8, 3)]
void StyleEncoderInstance(uint3 id : SV_DispatchThreadID)
{
	uint width = 256, depth = 3;
	float4 color = source[uint2(id.x, width - id.y - 1)];
	float arr[3] = { color.x, color.y, color.z };
	int z = id.z;
	int idx = StdID(id, width, depth);
	float mean = encoder_inst_statistic[z * 2];
	float variance = encoder_inst_statistic[z * 2 + 1];
	float inv = rsqrt(variance + EPSILON);
	float normalized = (arr[z] - mean) * inv;
	float scale = encoder_g_e0_bn_scale[z];
	float offset = encoder_g_e0_bn_offset[z];
	encoder_inst[idx] = scale * normalized + offset;
}

[numthreads(8, 8, 3)]
void StylePad(uint3 id : SV_DispatchThreadID) //id.xy=288
{
	uint pad = 15, width = 256, depth = 3;
	uint nwidth = width + 2 * pad; // 286

	if (StdCheckRange(id, nwidth)) return;

	int low = width - id.x - 1;
	int mid = id.x - pad;
	int high = 2 * pad + width - 1 - id.x;
	int x_array[3] = { low, mid, high };

	low = width - id.y - 1;
	mid = id.y - pad;
	high = nwidth - 1 - id.y;
	int y_array[3] = { low, mid, high };

	int x_id = id.x > (pad + width) ? 2 : saturate(id.x / pad);
	int y_id = id.y > (pad + width) ? 2 : saturate(id.y / pad);
	x_id = x_array[1];
	y_id = y_array[y_id];
	int indx = x_id * width * depth + y_id * depth + id.z;
	float color = encoder_inst[indx];
	indx = StdID(id, nwidth, depth);
	encoder_conv0[indx] = color;
}

[numthreads(8,8,1)]
void StyleConv1 (uint3 id : SV_DispatchThreadID) //id.xy=288 286x286x3->284x284x32
{
	uint input = 286, output = 284, depth1 = 3, stride =1;
	uint depth2 = StdCheckRange(id, output) ? 0 : 32;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 1, 0);
}

[numthreads(1, 32, 32)]
void StyleNormal1(uint3 id : SV_DispatchThreadID) //284x284x32
{
	uint width = 32, depth = 32, scale = 8;
	DefineEnNormal(id, width, depth, scale, 1);
}

[numthreads(8, 8, 4)]
void StyleInstance1(uint3 id : SV_DispatchThreadID) //284x284x32
{
	uint width = 284, depth = 32;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 1);
}

[numthreads(8,8,1)]
void StyleConv2(uint3 id : SV_DispatchThreadID) //id.xy=144 284x284x32->141x141x32 
{
	uint input = 284, output = 141, depth1 = 32, stride = 2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 32;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 2, 1);
}

[numthreads(1,32,32)]
void StyleNormal2(uint3 id : SV_DispatchThreadID)  //141x141x32 
{
	uint width = 32, depth = 32, scale = 4;
	DefineEnNormal(id, width, depth, scale, 2);
}

[numthreads(8,8,4)]
void StyleInstance2(uint3 id : SV_DispatchThreadID) //id.xy=144 141x141x32
{
	uint width = 141, depth = 32;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 2);
}

[numthreads(8,8,1)]
void StyleConv3 (uint3 id : SV_DispatchThreadID) //id.xy=72 141x141x32->70x70x64
{
	uint input = 141, output = 70, depth1 = 32, stride =2;
	uint depth2 = StdCheckRange(id, output) ? 64 : 0;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 3, 2)
}

[numthreads(1,REV_THREAD_Z,MAX_THREAD_Z)]
void StyleNormal3 (uint3 id : SV_DispatchThreadID)  // 70x70x64
{
	uint width = REV_THREAD_Z, depth = 64, scale = 4;
	DefineEnNormal(id, width, depth, scale, 3);
}

[numthreads(8,8,4)]
void StyleInstance3 (uint3 id : SV_DispatchThreadID) //id.xy=72 70x70x64 
{
	uint width = 70, depth = 64;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 3);
}

[numthreads(8,8,1)]
void StyleConv4 (uint3 id : SV_DispatchThreadID) //id.xy=40 70x70x64->34x34x128
{
	uint input = 70, output = 34, depth1 = 64, stride =2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 128;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 4, 3);
}

[numthreads(1,REV_THREAD_Z, MAX_THREAD_Z)] 
void StyleNormal4(uint3 id : SV_DispatchThreadID) //34x34x128
{
	uint width = 8, depth = 128, scale = 4;
	DefineEnNormalMaxZ(id, width, depth, scale, 4);
}

[numthreads(8,8,4)]
void StyleInstance4(uint3 id : SV_DispatchThreadID) //id.xy=40 34x34x128
{
	uint width = 34, depth = 128;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 4);
}

[numthreads(8,8,1)]
void StyleConv5(uint3 id : SV_DispatchThreadID) //id.xy=40 34x34x128->16x16x256
{
	uint input = 34, output = 16, depth1 = 128, stride = 2;
	uint depth2 = StdCheckRange(id, output) ? 0 : 256;
	DefineEncoderConv(id, input, output, depth1, depth2, stride, 5, 4);
}

[numthreads(1, REV_THREAD_Z, MAX_THREAD_Z)]
void StyleNormal5(uint3 id : SV_DispatchThreadID)  //16x16x256
{
	uint width = 4, depth = 256, scale = 4;
	DefineEnNormalMaxZ(id, width, depth, scale, 5);
}

[numthreads(8,8,4)]
void StyleInstance5 (uint3 id : SV_DispatchThreadID) //id.xy=16 16x16x256
{
	uint width = 16, depth = 256;
	if (StdCheckRange(id, width)) return;
	DefineEnInstRelu(id, width, depth, 5);
}